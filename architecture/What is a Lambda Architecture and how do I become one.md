## **What is a Lambda Architecture and how do I become one?**

Lambda架构看起来像这样：

![img](https://pic4.zhimg.com/v2-158a4c8ab606f3931f4a84420cb5e76b_b.jpg)

其工作方式是捕获不可变的记录序列并并行馈送到批处理系统和流处理系统中。实现转换逻辑两次，一次在批处理中，一次在流处理系统中，在查询时将两个系统的结果拼接在一起以生成完整答案。

这有很多变化，我故意简化一点。例如，你可以交换各种类似的系统来交换Kafka，Storm和Hadoop，人们经常使用两个不同的数据库来存储输出表，一个针对实时优化，另一个针对批量更新进行了优化。

Lambda 架构面向围绕需要以低延迟（例如几秒钟到几小时）运行的复杂异步转换构建的应用程序。一个很好的例子是新闻推荐系统，它需要抓取各种新闻源，处理和规范化所有输入，然后索引、排名和存储它以供服务。

我在LinkedIn参与构建了许多实时数据系统和管道。其中一些以这种风格工作，经过思考，这不是我最喜欢的方法。我认为有必要描述一下我认为这种架构的优缺点，并给出我更喜欢的替代方案。

## **What’s good about this?**

我喜欢 Lambda 架构强调保持输入数据不变。我认为将数据转换建模为原始输入的一系列具体化阶段的学科有很多优点。这是使大型MapReduce工作流易于处理的原因之一，因为它使您能够独立调试每个阶段。我认为这一课可以很好地转化为流处理领域。我[在这里](https://link.zhihu.com/?target=http%3A//engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying)写了一些关于捕获和转换不可变数据流的想法。

我也喜欢这种架构突出了重新处理数据的问题。再处理是流处理的主要挑战之一，但经常被忽视。我所说的“再处理”是指再次处理输入数据以重新派生输出。这是一个完全明显但经常被忽视的要求。代码将始终更改。因此，如果您有从输入流派生输出数据的代码，则每当代码更改时，都需要重新计算输出以查看更改的效果。

为什么代码会更改？它可能会发生变化，因为您的应用程序不断发展，并且您希望计算以前不需要的新输出字段。或者它可能会更改，因为您发现了错误并需要修复它。无论如何，当它发生时，您需要重新生成输出。我发现许多试图构建实时数据处理系统的人并没有对这个问题进行太多思考，最终得到的系统根本无法快速发展，因为它没有方便的方式来处理再处理。Lambda 架构在强调这个问题方面值得称赞。

对于 Lambda 架构，还有许多其他动机，但我认为它们没有多大意义。一是实时处理本质上是近似的，比批处理功能更弱，而且更有损。我实际上不认为这是真的。诚然，现有的流处理框架集不如MapReduce成熟，但是流处理系统没有理由不能像批处理系统那样提供强大的语义保证。

我听到的另一种解释是，Lambda 架构通过允许混合具有不同权衡的不同数据系统，以某种方式“击败了 CAP 定理”。长话短说，尽管在流处理中肯定存在延迟/可用性权衡，但这是一种异步处理的体系结构，因此计算的结果不会立即与传入数据保持一致。可悲的是，CAP定理仍然完好无损。

## **And the bad…**

Lambda 架构的问题在于，维护需要在两个复杂的分布式系统中产生相同结果的代码与看起来一样痛苦。我认为这个问题是无法解决的。

在Storm和Hadoop等分布式框架中编程很复杂。不可避免地，代码最终被专门设计用于运行它的框架。实施 Lambda 架构的系统由此产生的操作复杂性似乎是每个人都普遍同意的一件事。

为什么不能改进流处理系统以处理其目标域中的完整问题集？解决此问题的一种建议方法是使用一种在实时和批处理框架上进行抽象的语言或框架。你使用这个更高级别的框架编写代码，然后它“编译”为流处理或MapReduce。[Summingbird](https://link.zhihu.com/?target=http%3A//github.com/twitter/summingbird)是一个做到这一点的框架。这肯定会让事情变得更好一些，但我认为它不能解决问题。

最终，即使可以避免对应用程序进行两次编码，运行和调试两个系统的操作负担也将非常高。而任何新的抽象都只能提供两个系统交集所支持的功能。更糟糕的是，致力于这个新的超级框架将丰富的工具和语言生态系统隔离开来，这些工具和语言使Hadoop如此强大（Hive，Pig，Crunch，Cascading，Oozie等）。

通过类比，考虑使跨数据库ORM真正透明的臭名昭著的困难。并考虑这只是对非常相似的系统进行抽象的问题，这些系统提供与（几乎）标准化的界面语言几乎相同的功能。在勉强稳定的分布式系统之上抽象完全不同的编程范式的问题要困难得多。

## **An alternative**

作为设计基础设施的人，我认为一个突出的问题是：为什么不能改进流处理系统以处理其目标域中的全部问题集？为什么需要粘在另一个系统上？为什么不能同时进行实时处理，并在代码更改时处理重新处理？流处理系统已经具有并行性的概念;为什么不通过增加并行度和非常非常快速地重放历史记录来处理重新处理呢？答案是你可以做到这一点，我认为如果你今天正在构建这种类型的系统，这实际上是一个合理的替代架构。

当我与人们讨论这个问题时，他们有时会告诉我，流处理感觉不适合历史数据的高吞吐量处理。但我认为这是一种直觉，主要基于他们使用的系统的局限性，这些系统要么扩展性差，要么无法保存历史数据。这让他们有一种感觉，即流处理系统本质上是计算一些临时流的结果，然后丢弃所有底层数据的东西。但是没有理由这应该是真的。流处理中的基本抽象是数据流DAG，它们与传统数据仓库（*如*[火山](https://link.zhihu.com/?target=http%3A//paperhub.s3.amazonaws.com/dace52a42c07f7f8348b08dc2b186061.pdf)）中的底层抽象完全相同，也是MapReduce后继者Tez中的基本抽象。流处理只是此数据流模型的概括，它向最终用户公开中间结果和持续输出的检查点。

那么，我们如何直接从流处理作业进行再处理呢？我的首选方法实际上非常简单：

1. 使用 Kafka 或其他一些系统，它可以让你保留你希望能够重新处理的数据的完整日志，并允许多个订阅者。例如，如果要重新处理最多 30 天的数据，请将 Kafka 中的保留期设置为 30 天。
2. 如果要执行重新处理，请启动流处理作业的第二个实例，该实例从保留数据的开头开始处理，但将此输出数据定向到新的输出表。
3. 当第二个作业赶上时，将应用程序切换为从新表中读取。
4. 停止旧版本的作业，并删除旧输出表。

此体系结构如下所示：

![img](https://pic3.zhimg.com/v2-aaee2b11cc20333a0d5e3a8c02926a9e_b.jpg)

与 Lambda 架构不同，在此方法中，您仅在处理代码更改时进行重新处理，并且您实际上需要重新计算结果。当然，重新计算的工作只是相同代码的改进版本，运行在相同的框架上，获取相同的输入数据。当然，您将希望提高再处理作业的并行度，以便它非常快速地完成。

也许我们可以称之为Kappa架构，尽管它可能太简单了。

当然，您可以进一步优化。在许多情况下，可以组合两个输出表。但是，我认为在短时间内同时拥有两者有一些好处。这允许您立即恢复到旧逻辑，只需有一个按钮将应用程序重定向到旧表。在特别重要的情况下（例如您的广告定位标准），您可以使用自动 A/B 测试或bandit algorithm来控制切换，以确保您推出的任何错误修复或代码改进都不会意外降低与以前的版本相比。

请注意，这并不意味着您的数据不能进入 HDFS;这只是意味着您不在那里运行重新处理。Kafka与Hadoop有很好的集成，所以将任何Kafka主题镜像到HDFS中都很容易。流处理作业的输出甚至中间流在 Hadoop 中可用于在 Hive 等工具中进行分析或用作其他离线数据处理流的输入，这通常很有用。

## **Some background**

Kafka 维护如下有序日志：

![img](https://pic2.zhimg.com/v2-1114c826c788f2d4259350eccfe750b5_b.jpg)

Kafka“主题”是这些日志的集合：

![img](https://pic4.zhimg.com/v2-635d56e9568d1eb200f0d130cbf2b2bb_b.jpg)

使用此数据的流处理器仅维护一个“偏移量”，即它在每个分区上处理的最后一条记录的日志条目号。因此，更改使用者的位置以返回并重新处理数据就像使用不同的偏移量重新启动作业一样简单。为相同数据添加第二个使用者只是指向日志中不同位置的另一个读取器。

Kafka 支持复制和容错，在廉价的商用硬件上运行，并且很高兴每台机器存储许多 TB 的数据。因此，保留大量数据是一件非常自然且经济的事情，并且不会影响性能。LinkedIn使超过 PB 的 Kafka 存储保持在线状态，许多应用程序都充分利用了这种长保留模式来实现此目的。

廉价的消费者和保留大量数据的能力使得添加第二个“再处理”作业只需启动代码的第二个实例，但从日志中的不同位置开始。

这个设计并非偶然。我们构建 Kafka 的目的是将其用作流处理的基础，并且我们考虑的正是这种处理再处理数据的模型。

## **Comparison**

我知道这种方法使用 Samza 作为流处理系统效果很好，因为我们在LinkedIn这样做。但我不知道它不应该在 Storm 或其他流处理系统中同样出色地工作的任何原因。我对 Storm 不够熟悉，无法解决实际问题，所以我很高兴听到其他人是否已经在这样做了。无论如何，我认为总体思路是相当独立于系统的。

这两种方法之间的效率和资源权衡在某种程度上是一种洗牌。Lambda 架构需要始终运行重新处理和实时处理，而我建议的只需要在需要重新处理时运行作业的第二个副本。但是，我的建议要求在输出数据库中暂时拥有 2 倍的存储空间，并且需要一个支持大容量写入以进行重新加载的数据库。在这两种情况下，后处理的额外负载都可能会平均化。如果您有许多这样的作业，它们不会一次全部重新处理，因此在具有几十个此类作业的共享集群上，您可能会为在任何给定时间主动重新处理的少数作业额外预算百分之几的容量。

真正的优势根本不在于效率，而在于允许人们在单个处理框架之上开发、测试、调试和操作系统。因此，在简单性很重要的情况下，请考虑将此方法作为 Lambda 架构的替代方法。

## 总结

Kappa 架构利用了 Kafka 把日志数据保留在 Broker 本地硬盘，重放非常容易这样一个特点，提出了**放弃批处理层，转而在实时处理层提供多个程序版本的思路**。